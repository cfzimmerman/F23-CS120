**Binary search tree**

- BST is either â¦° or has a root R and every vertex has:
  - A key K
  - A value V
  - Left and right children V_l and V_r are each a valid BST and satisfying the BST property
- BST property:
  - For every vertex, the left child and all descendants of V are less than the key at that vertex. The right child and all children are greater than the current node.
- Because the BST definition is recursive, a single BST is almost always multiple BSTs
- Define height of a BST to be the length of the longest path from leaf to root

**Applied to Dynamic Predecessors**

- Operations:
  - `Insert(k, v)`
    - Sorted array: `O(n)`
  - `Delete(k)`
    - Sorted array: `O(n)`
  - `Search(k)`
    - Sorted array: `O(log n)`
  - `NextSmaller(k)`
    - Sorted array: `O(log n)`

**Prove correctness of insertion algorithm**

- Proving correctness of a data structure only requires proving the correctness of each operation upon it.
- As a stepping stone, prove by induction that insertion maintain the BST property:
  - Allows assumption that any tree with more than 0 nodes satisfies the BST property
  - This is purely internal to the implementation but is very convenient for future proofs
- Proof by induction on height `h` the claim "`Insert(T, (k, v))` maintains the BST property if `height(t) <= h`"
  - When _h = -1_: No vertices to check, empty tree satisfies
  - If true for N h: At Insert(T, (k, v)), T has a root v.
